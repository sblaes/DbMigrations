#!/bin/bash

#   Copyright 2011 Shaunak Kashyap
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

source /opt/db-migrations/libexec/logging.sh

# Configurables
DAYTIME_SERVERS=( time-a.timefreq.bldrdoc.gov time-b.timefreq.bldrdoc.gov time-c.timefreq.bldrdoc.gov time-d.timefreq.bldrdoc.gov )
DAYTIME_MAX_ATTEMPTS=5
RETRY_INTERVAL=5

get_random_server() {

    rand_idx=$(expr $RANDOM % 4)
    echo ${DAYTIME_SERVERS[$rand_idx]}

}

get_daytime_line() {

    let num_attempts=1
    while [ $num_attempts -lt $DAYTIME_MAX_ATTEMPTS ]; do

    msg_prefix="[Attempt $num_attempts/$DAYTIME_MAX_ATTEMPTS]"

    chosen_server=$(get_random_server)
    LOG_DEBUG "$msg_prefix Attempting to get DAYTIME line from $chosen_server..."

    line=$(telnet $chosen_server 13 2>/dev/null | tail -1 | grep '^[0-9]')
    if [ "$line" != "" ]; then
        echo "$line"
	    return
	    fi
	    
	    let num_attempts=num_attempts+1
	    LOG_DEBUG "$msg_prefix Attempt failed. Sleeping for $RETRY_INTERVAL seconds before retrying..."
	    sleep $RETRY_INTERVAL
    done

    LOG_DEBUG "Could not get DAYTIME line from servers in $DAYTIME_MAX_ATTEMPTS attempts. Giving up."
    exit 1
}

get_timestamp() {

    daytime_line=$(get_daytime_line)
    retval=$?
    if [ $retval -ne 0 ]; then
	exit $retval;
    fi

    echo $daytime_line | awk '{printf "20%s%s%03d",$2,$3,$7}' | sed 's/[-:]//g'

}

print_usage() {
    echo -e "Usage:\tcreate [-n <database name>] [-b <migrations base directory>] [-l <log level>]"
    echo 
    echo "Options:"
    echo -e  "\t-n <database name>"
    echo -e "\t\tSpecify the name of the database for which to create a migration. Required."
    echo
    echo -e "\t-b <migrations base directory>"
    echo -e "\t\tSpecify the base directory to store migrations files. Optional; default = ."
    echo
    echo -e "\t-l <log level"
    echo -e "\t\tSpecify the level of logging: DEBUG, INFO, WARNING, FATAL. Optional; default = INFO"
    echo
}

let LOG_LEVEL=$LOG_LEVEL_INFO

# Get user input
while getopts ":n:b:l:h" opt; do
    case $opt in
	n) DB_NAME=$OPTARG;;
	b) BASEDIR=$OPTARG;;
	l) LOG_LEVEL_STR=$OPTARG;;
	h) print_usage; exit 0;;
	:) LOG_FATAL "Option -$OPTARG requires an argument"; print_usage;  exit 1;;
    esac
done 
	    
if [ "$DB_NAME" == "" ]; then
    LOG_FATAL "Database name not specified."
    print_usage
    exit 2
fi

case $LOG_LEVEL_STR in
    DEBUG)   let LOG_LEVEL=$LOG_LEVEL_DEBUG;;
    INFO)    let LOG_LEVEL=$LOG_LEVEL_INFO;;
    WARNING) let LOG_LEVEL=$LOG_LEVEL_WARNING;;
    FATAL)   let LOG_LEVEL=$LOG_LEVEL_FATAL;;
esac

if [ "$BASEDIR" == "" ]; then
    BASEDIR=.
fi

# Generate timestamp
timestamp=$(get_timestamp)
retval=$?
if [ $retval -ne 0 ]; then
    LOG_FATAL "Could not generate unique timestamp for migration."
    exit $retval;
fi

# Create directories
dir=$BASEDIR/$DB_NAME/$timestamp
file=$dir/up
mkdir -p $dir
touch $file

echo "Created $file" >&2
